---
title: 数据结构-栈
date: 2020-03-17 01:14:27
categories:
  - 数据结构
tags:
  - 数据结构
---

数据结构-栈，介绍栈的数据结构。
<!-- more -->

------------
### 概念

栈（stack）是限定仅在表尾进行插入和删除的线性表，我们把允许插入和删除的一端称为栈顶（top），另一端为栈底（bottom），不含任何数据元素的栈称为空栈，栈又称为后进先出（Last In First Out）的线性表，简称LIFO结构。

非常贴切的例子，比如一摞叠在一起的盘子，放盘子的时候都是从下往上一个一个放，我们都是从上往下一个个依次取，不能从中间任意抽出，**后进者先出，先进者后出，这是典型的“栈”结构**

<img class="avatar" src="/img/stack.jpg">

### 实现栈

栈主要包含两个操作，入栈和出栈，也就是在栈顶插入一个数据和从栈顶删除一个数据。

栈既可以用数据实现，也可以用链表实现。用数组实现的栈，我们叫做**顺序栈**，用链表实现的栈，我们叫做 **链式栈**。

#### 数组实现

```java

// 基于数组实现的顺序栈
public class ArrayStack {
  private String[] items;  // 数组
  private int count;       // 栈中元素个数
  private int n;           //栈的大小

  // 初始化数组，申请一个大小为n的数组空间
  public ArrayStack(int n) {
    this.items = new String[n];
    this.n = n;
    this.count = 0;
  }

  // 入栈操作
  public boolean push(String item) {
    // 数组空间不够了，直接返回false，入栈失败。
    if (count == n) return false;
    // 将item放到下标为count的位置，并且count加一
    items[count] = item;
    ++count;
    return true;
  }
  
  // 出栈操作
  public String pop() {
    // 栈为空，则直接返回null
    if (count == 0) return null;
    // 返回下标为count-1的数组元素，并且栈中元素个数count减一
    String tmp = items[count-1];
    --count;
    return tmp;
  }
}
```

不管是顺序栈还是链式栈，我们存储数据只需要一个大小为n的数组就够了，在入栈和出栈的过程中，只需要一两个临时变量存储空间，所以空间复杂度为O(1)。入栈、出栈只设计栈顶个别数据的操作，所以时间复杂度都是O(1)。

#### 动态扩容

上面用数组实现的栈，是一个固定大小的栈，在初始化栈的时候需要实现指定栈的大小，当栈满了以后，就无法在往栈里添加数据了。尽管链式栈的大小不受限，但要存储next指针，内存消耗相对较多。我们如何基于数组实现一个支持动态扩容的栈呢？

数组实现动态扩容，当数组空间不够时，我们就重新申请一块更大的内存，将原来的数组中的数据拷贝过去。这样就实现了一个支持动态扩容的数组。

所以，要实现一个支持动态扩容的栈，我们只需要底层以来一个支持动态扩容的数组就可以了。当栈满了以后，我们就申请一个更大的数组，将原来的数据搬移到新的数组中去。

对于出栈的操作，我们不会设计内存的重新申请和数据搬移，所以出栈的时间复杂度仍然是O(1),但是对于入栈操作，情况就不一样了，当栈中有空闲空间时，入栈操作的时间复杂度为O(1);但当空间不够时，就需要重新申请内存和数据搬移，时间复杂度为O(n)。

### 栈的应用

#### 斐波那契数列实现

栈有一个很重要的应用：在程序设计语言中实现了递归，斐波那契数列是一个经典的递归例子。

斐波那契数列：如果兔子在出生两个月后，就有繁殖能力，一对兔子每个月能生出一对小兔子来。假设所有兔子不死，那么一年后可以繁殖多少对兔子呢？

我们拿新出生的一对兔子分析第一个月没有繁殖能力，所以还是一对，两个月后，生下一对总数为两队，三个月后老兔子又生了一对，因为小兔子还没繁殖能力......依次类推。

| 月份     | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 兔子对数 | 1    | 1    | 2    | 3    | 5    | 8    | 13   |

表中数字1，1，2，3，5，8，13......构成了一个序列，这个序列有个十分明显的特点，前面相邻两项之和，构成了后一项。用数学函数来定义就是：

F(n) = 0,当n=0;1,当n=1;F(n-1)+F(n-2),当n>1

代码实现：

```java
//斐波那契递归函数
public int fbi(int i){
  if(i<2){
    return i==0?0:1;
  }
  return fbi(i-1)+fbi(n-2);
} 

public static void main(String[] args){
  
  int i;
  for(i=0;i<40;i++){
    System.out.println(fbi(i));
  }
  
}
```

#### 表达式求值中的应用

实际上，编译器就是通过两个栈来实现的，其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈 ，当遇到运算符，就与运算符的栈顶元素进行比较。

如果运算符栈顶元素的优先级高 ，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取两个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。

表达式：3+5*8-6 的操作过程如下：

<img class="avatar" src="/img/biaodashi.jpg">

#### 括号匹配中的应用

假设表达式中只包含三种括号，圆括号()、方括号[]、和花括号{},并且它们可以任意嵌套。

可以用栈来检查是否合法。我们用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“（”和“）”匹配，则继续扫描剩余的字符串。如果在扫描的过程中，遇到不能匹配的右括号，或者栈中没有数据，则说明为非法格式。

当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式，否则，说明右为匹配的左括号，为非法格式。