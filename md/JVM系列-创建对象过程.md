---
title: JVM系列-创建对象过程
date: 2020-03-02 22:14:27
categories:
  - JVM
tags:
  - java
  - JVM
---

JVM系列-创建对象过程，介绍JVM虚拟机中创建对象的过程。
<!-- more -->

------------
### 创建对象的过程

Java创建对象的过程：

**类加载检查** --> **分配内存** --> **初始化零值** --> **设置对象头** --> **执行init方法**

#### 类加载检查

虚拟机遇到一个new指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析过和初始化过，如果没有必须先执行类的加载过程。

#### 分配内存

在类加载检查通过后，接下来虚拟机将会为新生对象分配内存，对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同把一块确定大小的内存从Java堆中划分出来。分配的方式有 **指针碰撞** 和 **空闲列表** 两种，选择哪种分配方式由java堆是否规整决定，而Java堆是否规整又由所采取的垃圾分集器是否有压缩整理功能决定。

##### 指针碰撞

使用场景：堆内存规整没有内存碎片的情况下

原理：用过的内存全部整理到一边，没有用过的内存放在另一边，中间有一个分界值的指针，只需要向着没用过的内存方向将该指针移动对象内存大小的位置即可

GC收集器：Serial、ParNew

##### 空闲列表

使用场景：堆内存不规整的情况下

原理：虚拟机会维护一个列表，该列表中会记录那些内存块是可用的，在分配的时候，找一块足够大的内存块划分给对象实例，最后更新列表记录。

##### 内存分配的并发安全

虚拟机采用两种方式来保证线程安全：

1. CAS+失败重试：CAS是乐观锁的一种实现方式，乐观锁就是每次不加锁而是在假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用CAS配上失败重试的方式保证原子性。
2. TLAB：为每个线程预先在Eden区分配一块内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大雨TLAB中的剩余内存或TLAB的内存已用尽，在采用上述的CAS进行内存分配

#### 初始化零值

内存分配完成后，虚拟机需要将分配到内存空间都初始化为零值，不包括对象头，这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段类型所对应的零值。

#### 设置对象头

初始化零值完成后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例，如何能找到类的元数据信息，对象的哈希码，对象的GC分代年龄信息等，这些对象存放在对象头中。另外根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

#### 执行init方法

在上面工作完成之后，从虚拟机的角度来看，一个新的对象已经产生了，但从Java程序的视角来看，对象的穿件才刚开始，init方法还没有执行，左右的字段都还是零。素有一般来说，执行new指令之后会接着执行init方法，把对象按照程序猿的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。



### 对象的内存布局

在Hostspot虚拟机中，对象在内存中的布局可以分为三块区域：对象头、实例数据、对齐填充。

#### 对象头

 Hostspot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身运行时的数据，如哈希码、GC分代年龄、锁状态标志等，另一部分时类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

#### 实例数据

实例数据部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。

#### 对齐填充

对齐填充部分不是必然存在的，也灭有什么特别的含义，仅仅是占位作用，因为Hostspot虚拟机的自动内存管理系统要求对象其实地址必须是8字节的整数倍，而对象头部分正好是8自己的整数倍，1倍或者2倍，因此，当对象实例数据部分没有对齐时，就需要通过填充来补全。

### 对象的访问定位

Java程序通过栈上的reference数据来操作堆上的具体对象。对象的访问方式有虚拟机的实现而定，目前主流的访问方式为：使用句柄和直接指针

#### 句柄

如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。（对象的实例数据在Java堆中，对象的类型数据在方法区）

#### 直接指针

如果使用世界指针访问，那么Java堆对象的布局就必须考虑如何防止访问类型数据的相关信息，reference中存储的直接就是对象的地址。



这两种对象的访问方式各有优势。使用句柄访问的最大好处是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改，使用直接指针访问方式最大的好处就是速度快，它节省了指针定位的时间开销。



### 特殊类对象的创建

#### String类和常量池

String对象的两种创建方式：

```java
String str = "java";
String str1 = new String("java");
System.out.println(str == str1);//false
```

这两种不同的创建方式是有差别的，第一种方式是在常量池中拿对象，第二种方式是直接在堆内存空间创建一个新的对象。（只要使用new方法，便需要创建新的对象）

##### intern方法

 String提供的intern方法，String.intern()是一个Native方法，它的作用是：如果运行时常量池中已经包含一个等于此String对象内容的字符串，则返回常量池中该字符串的引用，如果没有，则在常量池中创建与String内容相同的字符串，并返回常量池中创建的字符串的引用。

```java
String s1 = new String("java");
String s2 = new s1.intern();
String s3 = "java";
System.out.println(s2);//java
System.out.println(s1==s2);//false,s1在堆内，s2在常量池
System.out.println(s3==s2);//true,两个都在常量池中的同一个string对象
```

##### String字符串拼接

```java
String s1 = "hello";
String s2 = "world";
String s3 = "hello"+"world";//常量池中的对象
String s4 = s1+s2;//在堆上创建新的对象
String s5 = "helloworld";//常量池中的对象
System.out.println(s3 == s4);//false
System.out.println(s3 == s5);//true
System.out.println(s4 == s5);//false
```

尽量避免多个字符串对象拼接，这样会重新创建对象，可以使用StringBuilder或者StringBuffer。

```java
//String s1 = new String("java"); 一共创建了几个对象

String s1 = new String("java");//堆内存的地址值
String s2 = "java";
System.out.println(s1 == s2);//false
System.out.println(s1.equals(s2));//true
```

现有字符串“java”放入常量池，然后new 了一份“java”放入java堆。字符串常量“java”在编译器就已经放入常量池，而Java堆上的“java”是在运行期初始化阶段才确定的，然后Java栈的s1指向Java堆上的“java”。