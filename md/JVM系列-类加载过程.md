---
title: JVM系列-类加载过程
date: 2020-03-02 22:14:27
categories:
  - JVM
tags:
  - java
  - JVM
---

JVM系列-类加载过程，介绍JVM虚拟机中类的加载过程。
<!-- more -->

------------
### 类的生命周期

一个类完整的生命周期为：

**加载** --> **连接** -->**初始化**-->**使用**-->**卸载**

其中 **连接** 包括：**验证** --> **准备** --> **解析**



### 类的加载过程

Class文件需要加载到虚拟机中才能运行和使用，系统加载Class类型的文件分为三步：**加载** --> **连接** -->**初始化**，其中 **连接** 包括：**验证** --> **准备** --> **解析**

#### 加载

类加载过程的第一步，主要完成3件事情：

1. 通过全类名获取定义此类的二进制字节流
2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的class对象，作为方法区这些数据的访问入口

一个非数组类的加载阶段（获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式，即重写一个类加载器的loadclass方法，数组类型不同个类加载器创建，而是由java虚拟机直接创建。

类加载器在上一篇文章中已经介绍过了，忘记的

[点这里]: http://hehear.com/article/33.html

跳转过去。

加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能已经开始了。

#### 验证

**文件格式验证**：验证字节流是否符合Class文件格式规范，例如是否以0XCAFEBABE开头，注此版本好知否在当前虚拟机的处理范围之内，常量池中的常量是否有不备支持的类型。

**元数据验证**：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，例如：这个类是否有父类，除java.lang.object之外所有的类都有父类。这个类是否被继承了不允许继承的类（被finnal修饰）等等。

**字节码验证**：最复杂的一个阶段，通过数据流和控制流分析，确定程序语义是何方的，符合逻辑的，比如保证任意时刻操作数栈和指令代码序列都能配合工作。

**符号引用验证**：确保解析动作能正确执行。

#### 准备

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配的。对于该阶段应注意：

1. 这时候进行内存分配的仅包括类变量static，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。
2. 这里所设置的初始值通常情况下时数据类型的默认零值。如0，0L，null，false等，比如我们定义了public static int value=111,那么value变量在准备阶段初始值是0，而不是111初始化阶段才会进行赋值，特殊情况，比如给value变量加上final关键字，public static final int value=111，那么准备阶段value的值就被赋值就被赋值为111。

#### 解析

解析阶段是虚拟机将常量池内的**符号引用替换成直接引用**的过程，解析动作主要针对**类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符**七类符号引用进行。

**符号引用**就是一组符号来描述目标，可以任何字面量，直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。

在程序实际运行时，只有符号引用是不够的，举个例子：程序执行方法时，系统需要明确知道这个方法所在的位置，java虚拟机为每个类都准备了一张方法表来存放类中所有的方法，当需要调用一个类的方法的时候，只要一到这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。

解析阶段时虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。

#### 初始化

初始化时类加载的最后一步，也是真正执行类中定义的Java程序代码（字节码），初始化阶段是执行类构造器方法的过程。

对于构造器方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为构造器方法是带锁线程安全的，所以在多线程环境下进行初始化的话可能会引起死锁，并且这种死锁很难被发现。

对于初始化阶段，虚拟机严格规范了有且只有5种情况下，必须对类进行初始化：

1. 当遇到new、getstatic、put static、invokestatic这四条直接码指令时，比如new一个类，读取一个静态字段（未被final修饰）、或调用一个类的静态方法时。
2. 使用java.lang.reflect包的方法对类进行反射调用时，如果类没初始化，需要触发初始化。
3. 初始化一个类，如果其父类还未初始化，则先出发该父类的初始化。
4. 当虚拟机启动时，用户需要定义一个要执行的主类，包含main方法的那个类，虚拟机会先初始化这个类。
5. 当使用JDK1.7的动态语言时，如果一个 MethodHandle 实例的最后解析结构为 REF_getStatic、REF_putStatic、REF_invokeStatic、的方法句柄，并且这个句柄没有初始化，则需要先触发器初始化。

#### 卸载

卸载类即改类的Class对象被GC，卸载类需要满足3个要求：

1. 该类的所有实例对象都已被GC，也就是说堆不存在该类的实例对象。
2. 该类没有在其他任何地方被引用
3. 该类的类加载器的实例已被GC

所以，在JVM生命周期类，由jvm自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。

只要想通一点就好了，jdk自带的BootstrapClassLoader,PlatformClassLoader,AppClassLoader负责加载jdk提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。